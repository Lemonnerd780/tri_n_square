<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Whac-A-Mole Plus</title>
    <style>
        /* --- 基础设置 --- */
        body {
            margin: 0; padding: 0;
            background-color: #050505;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
            width: 100vw; height: 100vh;
        }

        /* 游戏主舞台 */
        #game-area {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }

        /* HUD 面板 */
        #ui-panel {
            position: absolute;
            top: 0; left: 0; width: 100%;
            padding: 10px 20px;
            padding-top: max(15px, env(safe-area-inset-top));
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 20;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            pointer-events: none;
        }

        .hud-text {
            color: #00d2ff;
            font-weight: 800;
            font-size: 16px;
            text-shadow: 0 0 8px rgba(0, 210, 255, 0.6);
            display: flex; flex-direction: column; align-items: center;
        }
        .hud-label { font-size: 10px; color: #666; margin-bottom: 2px; letter-spacing: 1px; }

        /* --- 弹窗样式 --- */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 100;
            display: flex; justify-content: center; align-items: center;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: #111;
            border: 2px solid #00d2ff;
            border-radius: 12px;
            padding: 30px 20px;
            width: 85%; max-width: 320px;
            text-align: center;
            color: white;
            box-shadow: 0 0 30px rgba(0, 210, 255, 0.2);
            animation: float 3s ease-in-out infinite;
        }
        @keyframes float { 0%,100%{transform:translateY(0);} 50%{transform:translateY(-8px);} }

        h1 { margin: 0 0 15px 0; color: #00d2ff; font-size: 26px; text-transform: uppercase; letter-spacing: 2px; }
        p { color: #ccc; font-size: 14px; line-height: 1.6; margin-bottom: 25px; }
        
        .btn {
            background: #0044aa; color: white;
            padding: 14px 0; width: 100%; border-radius: 8px;
            border: none; font-weight: bold; font-size: 16px;
            margin-top: 10px; cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 100, 255, 0.4);
            text-transform: uppercase; letter-spacing: 1px;
        }
        .btn:active { transform: scale(0.98); }

        .rules { text-align: left; background: rgba(255,255,255,0.08); padding: 15px; border-radius: 8px; margin-bottom: 20px; }
        .rule-row { display: flex; align-items: center; margin: 8px 0; font-size: 14px; }
        .icon-demo { width: 16px; height: 16px; margin-right: 12px; display: inline-block; }

        /* --- 图形样式 --- */
        .shape {
            position: absolute;
            opacity: 0; 
            transform: scale(0.8);
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s;
            will-change: transform, opacity;
        }

        .shape.active { opacity: 1; transform: scale(1); }

        .square {
            width: 75px; height: 75px;
            background: rgba(0, 40, 100, 0.9);
            border: 2px solid #00d2ff;
            box-shadow: 0 0 15px rgba(0, 210, 255, 0.3);
            border-radius: 6px;
        }

        .triangle {
            width: 80px; height: 80px;
            background: linear-gradient(180deg, #00d2ff 0%, #0044aa 100%);
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
            filter: drop-shadow(0 0 6px rgba(0, 210, 255, 0.6));
        }

        /* 错误提示文字 */
        .error-feedback {
            position: absolute;
            color: #ff0044; font-weight: 900; font-size: 18px;
            text-transform: uppercase; pointer-events: none; z-index: 99;
            text-shadow: 1px 1px 0 #000;
            animation: errorFloat 0.6s ease-out forwards;
        }
        @keyframes errorFloat { 0%{transform:translate(-50%, -50%) scale(0.5); opacity:1;} 100%{transform:translate(-50%, -150%) scale(1.5); opacity:0;} }

        /* 点击波纹 */
        .ripple {
            position: absolute; width: 20px; height: 20px;
            background: rgba(255,255,255,0.8); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 98;
            animation: rippleAnim 0.4s ease-out forwards;
        }
        @keyframes rippleAnim { to { transform: translate(-50%, -50%) scale(4); opacity: 0; } }

    </style>
</head>
<body>

    <div id="ui-panel">
        <div class="hud-text"><span class="hud-label">LEVEL</span><span id="txt-level">1/6</span></div>
        <div class="hud-text"><span class="hud-label">TIME</span><span id="txt-time">30</span></div>
        <div class="hud-text"><span class="hud-label">MISSED</span><span id="txt-miss">0/5</span></div>
    </div>

    <div id="game-area"></div>

    <!-- 弹窗 1: 开始 -->
    <div id="modal-start" class="modal">
        <div class="modal-content">
            <h1>HEYYYYY</h1>
            <p>Rules are simple.</p>
            <div class="rules">
                <div class="rule-row"><div class="icon-demo triangle"></div><span>Triangle: <b>1 TAP</b></span></div>
                <div class="rule-row"><div class="icon-demo square"></div><span>Square: <b>2 TAPS</b></span></div>
            </div>
            <p style="font-size:12px; color:#888;">* Don't double tap single targets! I know what you are thinking about! (btw AI is not gonna take away my job. It didn't think of this lol)</p>
            <button class="btn" onclick="startGame(1)">START GAME</button>
        </div>
    </div>

    <!-- 弹窗 2: 过关 -->
    <div id="modal-level" class="modal" style="display: none;">
        <div class="modal-content">
            <h1 id="lvl-title">Level Clear</h1>
            <p id="lvl-msg">Speed increasingggg...</p>
            <button id="lvl-btn" class="btn" onclick="nextLevel()">CONTINUE</button>
        </div>
    </div>

    <!-- 弹窗 3: 最终警告 -->
    <div id="modal-final" class="modal" style="display: none;">
        <div class="modal-content" style="border-color: #ff4444; box-shadow: 0 0 30px rgba(255,0,0,0.3);">
            <h1 style="color: #ff4444;">⚠️ WARNING</h1>
            <p>RULES HAVE CHANGED!<br>CONTROLS FLIPPED.</p>
            <div class="rules" style="background: rgba(100,0,0,0.3);">
                <!-- 图标样式保持蓝色 -->
                <div class="rule-row"><div class="icon-demo triangle"></div><span style="color:#ffaaaa">Triangle: <b>2 TAPS</b></span></div>
                <div class="rule-row"><div class="icon-demo square"></div><span style="color:#ffaaaa">Square: <b>1 TAP</b></span></div>
            </div>
            <button class="btn" style="background: #cc0000;" onclick="startGame(6)">I AM READY</button>
        </div>
    </div>

    <!-- 弹窗 4: 游戏结束 -->
    <div id="modal-gameover" class="modal" style="display: none;">
        <div class="modal-content" style="border-color: #666;">
            <h1 style="color: #888;">Mission Failed</h1>
            <p id="msg-fail">Too many errors:(</p>
            <button class="btn" style="background: #444;" onclick="retryLevel()">RETRY?</button>
        </div>
    </div>

    <!-- 弹窗 5: 通关 -->
    <div id="modal-victory" class="modal" style="display: none;">
        <div class="modal-content" style="border-color: #ffd700; box-shadow: 0 0 50px rgba(255, 215, 0, 0.4);">
            <h1 style="color: #ffd700;">CHAMPION!</h1>
            <p>Wooooo! You have beaten the system.<br>Now you can ask Judy for a reward;)</p>
            <button class="btn" style="background: #ffd700; color: #000;" onclick="location.reload()">PLAY AGAIN</button>
        </div>
    </div>

    <script>
        // --- 游戏配置 ---
        const CONFIG = {
            maxMissed: 5,
            levelTime: 30,
            doubleTapTime: 420, // 优化：由350ms增加到420ms，提升判定灵敏度和容错率
            shapeSize: 85 // 用于碰撞检测的预估尺寸
        };

        // --- 全局状态 ---
        let state = {
            level: 1,
            missed: 0,
            timeLeft: 30,
            isPlaying: false,
            shapes: [],     
            idCounter: 0,
            lastFrameTime: 0,
            spawnTimer: 0
        };

        let timerInterval = null;
        let animationFrame = null;

        const gameArea = document.getElementById('game-area');
        const txtLevel = document.getElementById('txt-level');
        const txtTime = document.getElementById('txt-time');
        const txtMiss = document.getElementById('txt-miss');

        // --- 游戏流程控制 ---

        function startGame(level) {
            // 隐藏所有弹窗
            document.querySelectorAll('.modal').forEach(el => el.style.display = 'none');
            
            // 重置数据
            state.level = level;
            state.missed = 0;
            state.timeLeft = CONFIG.levelTime;
            state.isPlaying = true;
            state.shapes = [];
            state.spawnTimer = 9999; // 确保第一帧立即生成
            state.idCounter = 0;
            gameArea.innerHTML = ''; 

            updateHUD();

            // 启动倒计时
            if(timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                state.timeLeft--;
                updateHUD();
                if(state.timeLeft <= 0) finishLevel(true);
            }, 1000);

            // 启动游戏循环
            if(animationFrame) cancelAnimationFrame(animationFrame);
            state.lastFrameTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        function nextLevel() {
            if(state.level < 5) startGame(state.level + 1);
            else if(state.level === 5) {
                document.getElementById('modal-level').style.display = 'none';
                document.getElementById('modal-final').style.display = 'flex';
            }
        }

        function retryLevel() {
            // 规则修改：如果第6关失败，退回到第4关
            if (state.level === 6) {
                startGame(4);
            } else {
                startGame(state.level);
            }
        }

        function finishLevel(success) {
            state.isPlaying = false;
            clearInterval(timerInterval);
            cancelAnimationFrame(animationFrame);

            if(success) {
                if(state.level === 6) {
                    // 通关
                    document.getElementById('modal-victory').style.display = 'flex';
                } else {
                    // 下一关
                    document.getElementById('lvl-title').innerText = "LEVEL CLEAR";
                    document.getElementById('lvl-msg').innerText = `Missed: ${state.missed} / ${CONFIG.maxMissed}`;
                    document.getElementById('modal-level').style.display = 'flex';
                }
            } else {
                // 失败
                let failText = `Missed ${state.missed} targets.`;
                if(state.level === 6) {
                    failText += "\n(Back to Level 4)"; // 提示用户将回退
                }
                document.getElementById('msg-fail').innerText = failText;
                document.getElementById('modal-gameover').style.display = 'flex';
            }
        }

        function updateHUD() {
            txtLevel.innerText = `${state.level}/6`;
            txtTime.innerText = state.timeLeft;
            txtMiss.innerText = `${state.missed}/${CONFIG.maxMissed}`;
            txtMiss.style.color = state.missed >= 3 ? '#ff3333' : '#00d2ff';
        }

        // --- 核心循环 ---

        function gameLoop(now) {
            if(!state.isPlaying) return;

            const dt = now - state.lastFrameTime;
            state.lastFrameTime = now;

            // 1. 难度参数计算
            let spawnInterval, maxLife;

            if (state.level < 6) {
                // 前5关：大幅提升难度增长幅度
                // 生成间隔：每升一关减少 160ms (原为120)，Level 5 时将达到 260ms 的高速
                spawnInterval = 900 - ((state.level - 1) * 160); 
                
                // 存活时间：每升一关减少 450ms (原为300)，逼迫玩家反应更快
                maxLife = 3000 - ((state.level - 1) * 450);      
            } else {
                // 第6关 (最终关) - 只有神能反应过来的速度
                spawnInterval = 210; // 指定为 150ms
                maxLife = 1100;       // 必须配合极短的存活时间，否则屏幕会瞬间爆满
            }

            // 2. 生成逻辑
            state.spawnTimer += dt;
            if(state.spawnTimer > spawnInterval) {
                spawnShape(maxLife);
                state.spawnTimer = 0 - (Math.random() * 200); // 增加一点随机间隔
            }

            // 3. 更新所有图形状态
            const shapesToRemove = [];
            state.shapes.forEach(shape => {
                shape.life -= dt;
                
                // 变透明逻辑
                if(shape.element) {
                    shape.element.style.opacity = shape.life / shape.maxLife;
                }

                // 消失逻辑
                if(shape.life <= 0) {
                    // 只有当它还没被标记为“濒死(成功待定)”时，才算Miss
                    if (!shape.isDying) {
                        handleMiss();
                    }
                    shapesToRemove.push(shape.id);
                }
            });

            shapesToRemove.forEach(id => removeShape(id));

            animationFrame = requestAnimationFrame(gameLoop);
        }

        function spawnShape(maxLife) {
            const id = ++state.idCounter;
            const isSquare = Math.random() > 0.5;
            
            // --- 碰撞检测与位置计算 ---
            const screenW = gameArea.clientWidth;
            const screenH = gameArea.clientHeight;
            const topSafe = 100; // 避开顶部HUD
            const bottomSafe = 50;
            const padding = 10;
            const shapeSize = CONFIG.shapeSize; // 85px

            let x, y;
            let isOverlapping = true;
            let attempts = 0;

            // 尝试 15 次寻找空位
            while(isOverlapping && attempts < 15) {
                attempts++;
                // 随机生成坐标
                x = Math.random() * (screenW - shapeSize - padding * 2) + padding;
                y = Math.random() * (screenH - shapeSize - topSafe - bottomSafe) + topSafe;
                
                // 检查是否与现有图形重叠
                isOverlapping = false;
                for (let s of state.shapes) {
                    // 简单的距离检查
                    const dx = (x + shapeSize/2) - (s.x + shapeSize/2);
                    const dy = (y + shapeSize/2) - (s.y + shapeSize/2);
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist < shapeSize + 10) { 
                        isOverlapping = true;
                        break;
                    }
                }
            }

            if (isOverlapping) return; // 没空位则放弃本帧生成

            // --- 创建元素 ---
            const el = document.createElement('div');
            el.className = `shape ${isSquare ? 'square' : 'triangle'}`;
            el.style.left = x + 'px';
            el.style.top = y + 'px';

            gameArea.appendChild(el);
            requestAnimationFrame(() => el.classList.add('active'));

            const shapeObj = { 
                id, 
                element: el, 
                life: maxLife, 
                maxLife, 
                x, y, // 存坐标用于碰撞检测
                isSquare,
                isDying: false,   // 是否处于单击后的判定等待期
                deathTimer: null  // 判定等待定时器
            };

            bindInput(el, shapeObj);
            state.shapes.push(shapeObj);
        }

        function bindInput(el, shape) {
            let lastTap = 0;

            el.addEventListener('touchstart', (e) => {
                e.preventDefault(); 
                const touch = e.touches[0];
                createRipple(touch.clientX, touch.clientY);

                const now = Date.now();
                const timeDiff = now - lastTap;

                // 判断是否需要双击
                let needDouble = false;
                if(state.level < 6) needDouble = shape.isSquare; // 1-5关: 正方形双击
                else needDouble = !shape.isSquare; // 6关: 三角形双击

                if (!needDouble) {
                    // --- 规则：只需单击 ---
                    
                    if (shape.isDying) {
                        // 逻辑：已经在“濒死等待期”，玩家又点了一下 -> 判定为误操作(Overclick)
                        clearTimeout(shape.deathTimer); // 取消原本的成功消除
                        removeShape(shape.id);          // 立即移除图形
                        handleMiss();                   // 扣分
                        showErrorFeedback(touch.clientX, touch.clientY); // 显示错误提示
                    } else {
                        // 逻辑：这是第一次点击
                        shape.isDying = true; 
                        lastTap = now;

                        // 视觉反馈：变灰，暗示“已击中”
                        el.style.opacity = '0.4'; 
                        el.style.filter = 'grayscale(100%)';
                        el.style.transform = 'scale(0.9)';

                        // 延迟判定成功
                        // 注意：这里延迟时间也稍微加长，配合 doubleTapTime 的增加
                        shape.deathTimer = setTimeout(() => {
                            removeShape(shape.id); // 真正的成功
                        }, CONFIG.doubleTapTime + 50); 
                    }

                } else {
                    // --- 规则：需要双击 ---
                    
                    if(timeDiff < CONFIG.doubleTapTime && timeDiff > 0) {
                        // 双击成功
                        removeShape(shape.id);
                        lastTap = 0;
                    } else {
                        // 第一次点击
                        lastTap = now;
                        // 视觉反馈：高亮，暗示“再点一下”
                        el.style.filter = "brightness(2)";
                        el.style.transform = 'scale(1.1)';
                        setTimeout(() => {
                            if(shape.element) {
                                shape.element.style.filter = "";
                                shape.element.style.transform = "scale(1)";
                            }
                        }, 150);
                    }
                }
            }, { passive: false });
        }

        // --- 辅助函数 ---

        function removeShape(id) {
            const idx = state.shapes.findIndex(s => s.id === id);
            if(idx !== -1) {
                const s = state.shapes[idx];
                if(s.deathTimer) clearTimeout(s.deathTimer);
                if(s.element && s.element.parentNode) {
                    s.element.parentNode.removeChild(s.element);
                }
                state.shapes.splice(idx, 1);
            }
        }

        function handleMiss() {
            state.missed++;
            updateHUD();
            document.body.style.backgroundColor = '#550000';
            setTimeout(() => document.body.style.backgroundColor = '#050505', 100);
            if(state.missed >= CONFIG.maxMissed) {
                finishLevel(false);
            }
        }

        function showErrorFeedback(x, y) {
            const el = document.createElement('div');
            el.className = 'error-feedback';
            el.innerText = "OVERCLICK!";
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 600);
        }

        function createRipple(x, y) {
            const r = document.createElement('div');
            r.className = 'ripple';
            r.style.left = x + 'px';
            r.style.top = y + 'px';
            document.body.appendChild(r);
            setTimeout(() => r.remove(), 400);
        }

    </script>
</body>
</html>




